const int SDM220VAR[]  =  {
		0x0000,
		0x0006,
		0x000C,
		0x0012,
		0x0018,
		0x001E,
		0x0024,
		0x0046,
		0x0048,
		0x004A,
		0x004C,
		0x004E,
		0x0056,
		0x0058};
const std::string SDM220STR[] = {"Volts", "Amps", "Watts", "VoltAmps", "VAr", "None", "Degree" , "Hz", "kwh", "kwh", "kvarh", "kvarh", "kwh", "kvarh"};


#include <math.h>



#include </home/caricardo/Modbus/Libs/libmodbus-3.1.4/src/modbus.h>


float bintofloat(uint32_t x) {
    float *f = (float *)&x;
    return *f;
}

int main()
{
	 modbus_t *SModBus;
	 float Buffer[3];
	 uint8_t ReadedRegisters;
	 uint16_t Cash_ModBus[2];
	 SModBus = modbus_new_rtu("/dev/ttyS1", 9600, 'N', 8, 1);
	 modbus_set_slave(SModBus, 1);
	 if (modbus_connect(SModBus) == -1) {
	     cout << "ERR" << endl;
	     return -1;
	 }

	 cout << "----" << endl;
while(1==1)
{
	for(int i = 0; i < 3; i ++ )
		 {
			 ReadedRegisters = modbus_read_input_registers(SModBus, SDM220VAR[i], 2, Cash_ModBus);
			 cout << bintofloat((Cash_ModBus[0]<<16) | (Cash_ModBus[1])) << " " << SDM220STR[i] << endl;
		 }
	printf("\x1B[2J\x1B[H");
}

	 modbus_close(SModBus);
	 modbus_free(SModBus);
}

----------------------------------------------------------------


#include <iostream>
#include <fstream>
#include <modbus.h>
#include <XMLwriter.h>
#include <map>
#include <iterator>

using namespace std;

const map <string, uint16_t> SDM220regsStr = {
{"Line_to_neutral_volts",  0x0000},//Volts
{"Current", 			   0x0006},//Amps
{"Active_power", 		   0x000C},//Watts
{"Apparent_power", 		   0x0012},//VoltAmps
{"Reactive_power", 		   0x0018},//VAr
{"Power_factor", 		   0x001E},//None
{"Phase_angle", 		   0x0024},//Degree
{"Frequency", 			   0x0046},//Hz
{"Import_active energy",   0x0048},//kwh
{"Export_active energy",   0x004A},//kwh
{"Import_reactive energy", 0x004C},//kvarh
{"Export_reactive energy", 0x004E},//kvarh
{"Total_active energy",    0x0056},//kwh
{"Total_reactive energy",  0x0058}};//kvarh

const map <uint8_t, uint16_t> SDM220regsInt = {
{0, 0x0000},//Volts
{1, 0x0006},//Amps
{2, 0x000C},//Watts
{3, 0x0012},//VoltAmps
{4, 0x0018},//VAr
{5, 0x001E},//None
{6, 0x0024},//Degree
{7, 0x0046},//Hz
{8, 0x0048},//kwh
{9, 0x004A},//kwh
{10, 0x004C},//kvarh
{11, 0x004E},//kvarh
{12, 0x0056},//kwh
{13, 0x0058}};//kvarh

/*const int SDM220regs[]  =  {
		0x0000,
		0x0006,
		0x000C,
		0x0012,
		0x0018,
		0x001E,
		0x0024,
		0x0046,
		0x0048,
		0x004A,
		0x004C,
		0x004E,
		0x0056,
		0x0058
};
*/

char const *toChar(float x)
{
	std::string s = std::to_string(x);
	char const *voltage = s.c_str();
	return voltage;
}

const std::string SDM220STR[] = {"Volts", "Amps", "Watts", "VoltAmps", "VAr", "None", "Degree" , "Hz", "kwh", "kwh", "kvarh", "kvarh", "kwh", "kvarh"};

float bintofloat(uint32_t x) {
    float *f = (float *)&x;
    return *f;
}

ofstream XMLout;
uint16_t SDM220buf[2];
float SDM220statusBuf[14];

int main()
{
	modbus_t *SDM220 = modbus_new_rtu("/dev/ttyUSB0", 9600, 'N', 8, 1);
	modbus_set_slave(SDM220, 1);
	if (modbus_connect(SDM220) == -1) {
		cout << "ERR" << endl;
		return -1;
		}
	for(int i = 0; i < 14; i ++ ){
		modbus_read_input_registers(SDM220, SDM220regsInt.at(i), 2, SDM220buf);
		SDM220statusBuf[i] = bintofloat((SDM220buf[0]<<16) | (SDM220buf[1]));
	}
		 modbus_close(SDM220);
		 modbus_free(SDM220);
	XMLout.open("/home/caricardo/tmpfs/sdm220.txt");
	cout << "!!!Hello World!!!" << endl; // prints !!!Hello World!!!
	XMLwriter writer(XMLout);
	writer.openElt("SDM220");
	//writer.openElt("voltage").content(voltage).closeAll();
	writer.openElt("Line_to_neutral_volts").content(std::to_string(SDM220statusBuf[0]).c_str()).closeElt();
	writer.openElt("Current").content(std::to_string(SDM220statusBuf[1]).c_str()).closeElt();
	writer.openElt("Active_power").content(std::to_string(SDM220statusBuf[2]).c_str()).closeElt();
	writer.openElt("Apparent_power").content(std::to_string(SDM220statusBuf[3]).c_str()).closeElt();
	writer.openElt("Reactive_power").content(std::to_string(SDM220statusBuf[4]).c_str()).closeElt();
	writer.openElt("Power_factor").content(std::to_string(SDM220statusBuf[5]).c_str()).closeElt();
	writer.openElt("Phase_angle").content(std::to_string(SDM220statusBuf[6]).c_str()).closeElt();
	writer.openElt("Frequency").content(std::to_string(SDM220statusBuf[7]).c_str()).closeElt();
	writer.openElt("Import_active energy").content(std::to_string(SDM220statusBuf[8]).c_str()).closeElt();
	writer.openElt("Export_active energy").content(std::to_string(SDM220statusBuf[9]).c_str()).closeElt();
	writer.openElt("Import_reactive energy").content(std::to_string(SDM220statusBuf[10]).c_str()).closeElt();
	writer.openElt("Export_reactive energy").content(std::to_string(SDM220statusBuf[11]).c_str()).closeElt();
	writer.openElt("Total_active energy").content(std::to_string(SDM220statusBuf[12]).c_str()).closeElt();
	writer.openElt("Total_reactive energy").content(std::to_string(SDM220statusBuf[13]).c_str()).closeElt();
	writer.closeAll();
	/*
	"Line_to_neutral_volts",  0x0000},//Volts
	{"Current", 			   0x0006},//Amps
	{"Active_power", 		   0x000C},//Watts
	{"Apparent_power", 		   0x0012},//VoltAmps
	{"Reactive_power", 		   0x0018},//VAr
	{"Power_factor", 		   0x001E},//None
	{"Phase_angle", 		   0x0024},//Degree
	{"Frequency", 			   0x0046},//Hz
	{"Import_active energy",   0x0048},//kwh
	{"Export_active energy",   0x004A},//kwh
	{"Import_reactive energy", 0x004C},//kvarh
	{"Export_reactive energy", 0x004E},//kvarh
	{"Total_active energy",    0x0056},//kwh
	{"Total_reactive energy",  0x0058}};//kvarh
	*/
	//std::cout << std::endl;
	return 0;
}
